---
layout: post
title: "正则表达式的那点事"
category: ""
tags: []
date: 2013-12-04 11:12:37 +0800
---
正则表达式是一种**字符串模式**，用于匹配**字符串集合**中符合该模式的所有**字符串**。

需求促进发明与进步这句话我觉得可以用在学习正则表达式上。

我们有这样一个文本：
<pre>
  My name is xx, a postgraduate student from Tianjin University, and will get my master degree in March 2007. My Phone number is 027-86868686. I'd like to summarize myself from 3 aspects:
  First, I'm an excellent learner. In my sophomore year, I passed the entrance examination to the Excellent Student Program in Tianjin University and was recommended as the postgraduate student with special courses, and then I joined the IBM Center in Tianjin University. 010-82341388. After finishing my undergraduate courses, my GPA was 3.8 out of 4.5.
</pre>
现在我们有一系列的需求，看我们是如何完成这些需求，并在此过程中学习正则表达式一些规则的设计原则。

<h3>第一个需求：<small>找到文本中包含027-86868686字符串的所有位置，用于修改，计数等等</small></h3>

这里，可以用最傻的办法来完成需求。直接采用**字符串字面值**这种字符串模式来正则匹配，例如此处即用"027-86868686"来对整个文本匹配，文本中和这个电话号码字符串一样的就会被查找到。**字符串字面值**匹配法是最基本的正则匹配法，但是这个方法局限性太大，如果需求稍微变更下就会特别麻烦。

<h3>第二个需求：<small>找到文本中所有11位电话号码</small></h3>

在此，字符串字面值的匹配方法肯定不行了，因为你不能写出还可能存在的电话号码的字面值是什么。怎么办？可以发现电话号码都是由0-9数字构成，共11个数字加一个“－”号。我们能用一种方式表示0-9中的某一个数字，这样就能完成需求了。  
如此，**字符组**就被设计出来了，`[0-9]`这种写法就表示0到9之内的任何一个数，它就是数字的字符组表示方法。  
根据字符组，我们写出这种字符串模式用于正则匹配。即`[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]`。它就可以用于匹配所有由三个区号一个“－”加八位电话号组成的固定电话号码了。可以说它是对所有电话号码这种的共同点抽象，然后表现出来的一种模式。 


<h3>第三个需求：<small>第二个需求中的字符串模式写法太复杂，需要简洁写法</small></h3>

碰到这种问题，一个方法，去抽象它！`[0-9]`这种写法麻烦了，要敲5次键盘。我们发现它是经常会被用到的，那就用`\d`这种写法来表示它,即`\d等价于[0-9]`。这样，我们可以把上面的字符串模式简洁成这样：`\d\d\d-\d\d\d\d\d\d\d`。  
这种`\d`的写法，我们称为**字符组简写**。

<h3>第四个需求：<small>还是觉得第三个需求中的字符串模式写法冗余度太高，求修改</small></h3>

的确，第三种写法中`\d`的重复度太高。抽象它！通过给`\d`后面加**量词**来表示多个连续重复的写法。在正则表达式中设计了这样一种写法，`\d{3}`即等价于`\d\d\d`。  
这种使用量词的写法极大的减少了字符串模式的长度，现在变成了这样的写法：`\d{3}-\d{8}`。它的效果等价于第二种写法。

<h3>第五个需求：<small>电话号码的中的那个"-"可能不是固定的表示法，例如有的人可能喜欢用“*”、“～”等其他字符表示。</small></h3>

这里，如何解决这个需求？我们需要一个抽象的符号表示所有这种可能的用法。利用学到的字符组概念，我们可以用`[-*~]`这种方式来表示。但是，这是中不完全的表示法，可能有别的字符没考虑进去。
这时，`.`这种表示任意字符的抽象符号就有用处了。所以可以用``\d{3}.\d{8}`这种写法解决号这个需求。不论是"027~86868686"还是"027*86868686"都是可以被匹配的。

<h3>第六个需求：<small>我喜欢吉利数字，喜欢由4组类似86这种数字对组成的电话号码，并全部匹配出来。例如68686868等等。</small></h3> 
  
这类数字的特点是重复，如何保证这一点呢？正则表达式采用了一种有意思的方法来解决这个问题，即**捕获分组**，注意这是一个名词，可能有点怪异。  
我们认为一对"()"括起来的内容即是一个“捕获分组”，它可以在书写字符串模式时以一种简单的方式被引用，即**向后引用**的策略。例如，用`(\d\d)\1\1\1`就可以满足这种需求。这里我们可以结合量词用一种简写表示`(\d\d)\1{3}`，但是我们不能直接使用`(\d\d){4}`的表示方法，它只有捕获分组的用法，但并不包含向后引用的用法，它等价于`\d{8}`。   

<h3>总结</h3>
到这我们学到了正则表达式的一些最基本“原子结构”，任何复杂的正则表达都是由它们组合抽象而成。
通过上面的分析，发现正则表达语法主要由以下几个部分构成：

**基本的字符匹配模式**  
按抽象的层次排序分为：

* 字面值匹配：例如字符 `a` 匹配 字符串中 `a` 字符
* 字符组匹配：匹配字符组中某一个字符，如[0-9] [a-zA-Z]等等
* 字符组简写匹配：例如`\d等价于[0-9]`，`\w 等价于 [_a-zA-Z0-0]`

**量词语法**  
用于简化字符串模式的书写:
通过`{数字}`的结构，控制其前面的分组或者某个字符匹配模式的数量

**分组语法**  
用于将多个字符匹配模式捆绑成一个个体，可以用于进行量词控制数量，或者用于向后引用。